# 通道速率控制功能说明

## 功能概述

为短信通道添加速率控制功能，支持多维度的流量限制，保护通道稳定性，防止超频请求导致的服务异常。

## 新增功能

### 1. 速率控制开关

- **功能**：可选择是否启用速率控制
- **字段**：`rate_limit_enabled`
- **类型**：布尔值（开关）
- **默认值**：关闭

### 2. 多维度速率限制

#### （1）每秒限制
- **字段**：`rate_limit_per_second`
- **说明**：每秒最大发送请求数
- **范围**：0-1000
- **用途**：防止瞬间流量过大，适用于高频短信发送

#### （2）每分钟限制
- **字段**：`rate_limit_per_minute`
- **说明**：每分钟最大发送请求数
- **范围**：0-60000
- **用途**：控制总体发送量，防止超出供应商限制

#### （3）每小时限制
- **字段**：`rate_limit_per_hour`
- **说明**：每小时最大发送请求数
- **范围**：0-3600000
- **用途**：长期流量控制，防止单小时发送过多

#### （4）最大并发数
- **字段**：`rate_limit_concurrent`
- **说明**：同时进行的最大请求数
- **范围**：1-100
- **用途**：限制并发请求，保证服务稳定性

## 数据库变更

### 新增字段

```sql
ALTER TABLE sms_channels 
  ADD COLUMN rate_limit_enabled TINYINT(1) DEFAULT 0 
    COMMENT '是否启用速率控制' AFTER daily_limit,
    
  ADD COLUMN rate_limit_per_second INT DEFAULT NULL 
    COMMENT '每秒最大请求数' AFTER rate_limit_enabled,
    
  ADD COLUMN rate_limit_per_minute INT DEFAULT NULL 
    COMMENT '每分钟最大请求数' AFTER rate_limit_per_second,
    
  ADD COLUMN rate_limit_per_hour INT DEFAULT NULL 
    COMMENT '每小时最大请求数' AFTER rate_limit_per_minute,
    
  ADD COLUMN rate_limit_concurrent INT DEFAULT NULL 
    COMMENT '最大并发请求数' AFTER rate_limit_per_hour;
```

### 字段说明

| 字段名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| rate_limit_enabled | TINYINT(1) | 0 | 是否启用速率控制 |
| rate_limit_per_second | INT | NULL | 每秒最大请求数 |
| rate_limit_per_minute | INT | NULL | 每分钟最大请求数 |
| rate_limit_per_hour | INT | NULL | 每小时最大请求数 |
| rate_limit_concurrent | INT | NULL | 最大并发请求数 |

## 前端界面

### 配置表单

```vue
<!-- 速率控制开关 -->
<el-form-item label="启用速率控制">
  <el-switch
    v-model="temp.rate_limit_enabled"
    active-text="开启"
    inactive-text="关闭"
  />
</el-form-item>

<!-- 当启用时显示详细配置 -->
<div v-if="temp.rate_limit_enabled">
  <!-- 每秒限制 -->
  <el-form-item label="每秒限制">
    <el-input-number 
      v-model="temp.rate_limit_per_second" 
      :min="0" 
      :max="1000"
    />
  </el-form-item>
  
  <!-- 每分钟限制 -->
  <el-form-item label="每分钟限制">
    <el-input-number 
      v-model="temp.rate_limit_per_minute" 
      :min="0" 
      :max="60000"
    />
  </el-form-item>
  
  <!-- 每小时限制 -->
  <el-form-item label="每小时限制">
    <el-input-number 
      v-model="temp.rate_limit_per_hour" 
      :min="0" 
      :max="3600000"
    />
  </el-form-item>
  
  <!-- 最大并发数 -->
  <el-form-item label="最大并发数">
    <el-input-number 
      v-model="temp.rate_limit_concurrent" 
      :min="1" 
      :max="100"
    />
  </el-form-item>
</div>
```

### 配置示例

#### 示例 1：高频通道（每秒发送）
```javascript
{
  rate_limit_enabled: true,
  rate_limit_per_second: 10,      // 每秒最多10条
  rate_limit_per_minute: 500,     // 每分钟最多500条
  rate_limit_per_hour: 20000,     // 每小时最多20000条
  rate_limit_concurrent: 5        // 最多5个并发
}
```

#### 示例 2：普通通道
```javascript
{
  rate_limit_enabled: true,
  rate_limit_per_second: 5,       // 每秒最多5条
  rate_limit_per_minute: 200,     // 每分钟最多200条
  rate_limit_per_hour: 10000,     // 每小时最多10000条
  rate_limit_concurrent: 3        // 最多3个并发
}
```

#### 示例 3：低频通道
```javascript
{
  rate_limit_enabled: true,
  rate_limit_per_second: 2,       // 每秒最多2条
  rate_limit_per_minute: 100,     // 每分钟最多100条
  rate_limit_per_hour: 5000,      // 每小时最多5000条
  rate_limit_concurrent: 1        // 最多1个并发
}
```

## 使用场景

### 1. 防止超频

**场景**：供应商限制每秒最多10条短信

**配置**：
```javascript
rate_limit_per_second: 10
```

**效果**：当发送速度超过10条/秒时，自动排队或拒绝

### 2. 控制总量

**场景**：每小时最多发送5000条

**配置**：
```javascript
rate_limit_per_hour: 5000
```

**效果**：达到5000条后，停止发送或返回错误

### 3. 保护服务

**场景**：避免过多并发导致服务崩溃

**配置**：
```javascript
rate_limit_concurrent: 5
```

**效果**：最多5个请求同时进行，其他排队等待

### 4. 组合控制

**场景**：精细化流量管理

**配置**：
```javascript
{
  rate_limit_per_second: 10,
  rate_limit_per_minute: 500,
  rate_limit_per_hour: 20000,
  rate_limit_concurrent: 5
}
```

**效果**：多维度限流，更精准控制

## 后端实现建议

### 1. 速率限制中间件

```javascript
// backend/middleware/rateLimiter.js
const redis = require('redis');
const client = redis.createClient();

class RateLimiter {
  // 检查是否超过速率限制
  async checkRateLimit(channel, type) {
    const key = `rate_limit:${channel.id}:${type}`;
    
    switch(type) {
      case 'second':
        return await this.checkLimit(key, channel.rate_limit_per_second, 1);
      case 'minute':
        return await this.checkLimit(key, channel.rate_limit_per_minute, 60);
      case 'hour':
        return await this.checkLimit(key, channel.rate_limit_per_hour, 3600);
      default:
        return true;
    }
  }
  
  async checkLimit(key, limit, ttl) {
    if (!limit || limit === 0) return true; // 未设置限制
    
    const count = await client.incr(key);
    
    if (count === 1) {
      await client.expire(key, ttl);
    }
    
    return count <= limit;
  }
  
  // 检查并发限制
  async checkConcurrent(channel) {
    if (!channel.rate_limit_concurrent) return true;
    
    const key = `concurrent:${channel.id}`;
    const current = await client.get(key) || 0;
    
    return parseInt(current) < channel.rate_limit_concurrent;
  }
  
  // 增加并发计数
  async incrementConcurrent(channel) {
    const key = `concurrent:${channel.id}`;
    await client.incr(key);
  }
  
  // 减少并发计数
  async decrementConcurrent(channel) {
    const key = `concurrent:${channel.id}`;
    await client.decr(key);
  }
}

module.exports = new RateLimiter();
```

### 2. 发送服务集成

```javascript
// backend/services/smsService.js
const rateLimiter = require('../middleware/rateLimiter');

async function sendSms(channel, phone, content) {
  // 检查速率限制
  if (channel.rate_limit_enabled) {
    // 检查每秒限制
    const allowedSecond = await rateLimiter.checkRateLimit(channel, 'second');
    if (!allowedSecond) {
      throw new Error('超过每秒发送限制');
    }
    
    // 检查每分钟限制
    const allowedMinute = await rateLimiter.checkRateLimit(channel, 'minute');
    if (!allowedMinute) {
      throw new Error('超过每分钟发送限制');
    }
    
    // 检查每小时限制
    const allowedHour = await rateLimiter.checkRateLimit(channel, 'hour');
    if (!allowedHour) {
      throw new Error('超过每小时发送限制');
    }
    
    // 检查并发限制
    const allowedConcurrent = await rateLimiter.checkConcurrent(channel);
    if (!allowedConcurrent) {
      throw new Error('超过最大并发数');
    }
    
    // 增加并发计数
    await rateLimiter.incrementConcurrent(channel);
  }
  
  try {
    // 实际发送逻辑
    const result = await actualSend(channel, phone, content);
    return result;
  } finally {
    // 减少并发计数
    if (channel.rate_limit_enabled) {
      await rateLimiter.decrementConcurrent(channel);
    }
  }
}
```

### 3. 使用 Redis 存储计数

**优势**：
- ✅ 高性能
- ✅ 支持过期时间
- ✅ 原子操作
- ✅ 分布式支持

**安装 Redis**：
```bash
# CentOS
yum install redis

# 启动 Redis
systemctl start redis
systemctl enable redis

# Node.js 依赖
npm install redis
```

## 配置建议

### 1. 根据供应商限制配置

| 供应商 | 每秒限制 | 每分钟限制 | 每小时限制 | 并发数 |
|--------|---------|-----------|-----------|--------|
| 考拉短信 | 10 | 500 | 20000 | 5 |
| SMS57 | 5 | 200 | 10000 | 3 |
| Twilio | 20 | 1000 | 50000 | 10 |

### 2. 根据业务需求配置

| 业务类型 | 每秒限制 | 每分钟限制 | 每小时限制 | 并发数 |
|---------|---------|-----------|-----------|--------|
| 验证码 | 10 | 500 | 20000 | 5 |
| 营销短信 | 5 | 200 | 10000 | 3 |
| 通知短信 | 2 | 100 | 5000 | 2 |

### 3. 保守起步，逐步优化

**建议**：
1. 初始配置设置较低值
2. 监控实际使用情况
3. 根据数据逐步调整
4. 留有安全余量

## 监控与告警

### 1. 监控指标

- 实时QPS（每秒请求数）
- 分钟级流量
- 小时级流量
- 并发请求数
- 限流触发次数
- 限流拒绝率

### 2. 告警规则

```javascript
// 限流触发率 > 10%
if (rateLimitRejectRate > 0.1) {
  alert('速率限制频繁触发，建议调整配置');
}

// 接近限制阈值
if (currentQPS > rateLimit * 0.9) {
  alert('接近速率限制，请注意');
}
```

## 测试验证

### 1. 功能测试

```javascript
// 测试用例 1：未启用速率控制
{
  rate_limit_enabled: false
}
// 预期：正常发送，无限制

// 测试用例 2：启用但未设置限制
{
  rate_limit_enabled: true,
  rate_limit_per_second: 0
}
// 预期：正常发送，无限制

// 测试用例 3：设置每秒限制
{
  rate_limit_enabled: true,
  rate_limit_per_second: 5
}
// 预期：第6条开始被限制

// 测试用例 4：设置并发限制
{
  rate_limit_enabled: true,
  rate_limit_concurrent: 2
}
// 预期：最多2个请求同时进行
```

### 2. 压力测试

```bash
# 使用 Apache Bench 测试
ab -n 1000 -c 10 http://localhost:3000/api/sms/send

# 观察限流效果
```

## 注意事项

### 1. 数据库迁移

⚠️ **重要**：需要手动执行SQL脚本添加字段

```bash
# 执行迁移脚本
mysql -u root -p sms_system < scripts/add-rate-limit-fields.sql
```

### 2. 后端实现

⚠️ **提示**：前端配置已完成，后端需要实现速率限制逻辑

**待实现**：
- [ ] Redis 连接配置
- [ ] 速率限制中间件
- [ ] 发送服务集成
- [ ] 监控统计

### 3. 默认值

**新创建通道**：
- rate_limit_enabled: false（关闭）
- 其他字段: 0 或 NULL

**建议**：
- 不强制启用
- 由用户根据需要配置

## 修改文件

### 前端文件

- `/home/vue-element-admin/src/views/sms/admin/channels.vue`
  - 新增速率控制表单配置
  - 更新 temp 对象
  - 更新 resetTemp 方法

### 后端文件

- `/home/vue-element-admin/backend/models/SmsChannel.js`
  - 新增 5 个速率控制字段

### 数据库脚本

- `/home/vue-element-admin/scripts/add-rate-limit-fields.sql`
  - 添加字段的 SQL 脚本

## 使用步骤

### 1. 执行数据库迁移

```bash
# 连接到数据库
mysql -u root -p

# 选择数据库
USE sms_system;

# 执行添加字段
ALTER TABLE sms_channels 
  ADD COLUMN rate_limit_enabled TINYINT(1) DEFAULT 0 
    COMMENT '是否启用速率控制' AFTER daily_limit,
  ADD COLUMN rate_limit_per_second INT DEFAULT NULL 
    COMMENT '每秒最大请求数' AFTER rate_limit_enabled,
  ADD COLUMN rate_limit_per_minute INT DEFAULT NULL 
    COMMENT '每分钟最大请求数' AFTER rate_limit_per_second,
  ADD COLUMN rate_limit_per_hour INT DEFAULT NULL 
    COMMENT '每小时最大请求数' AFTER rate_limit_per_minute,
  ADD COLUMN rate_limit_concurrent INT DEFAULT NULL 
    COMMENT '最大并发请求数' AFTER rate_limit_per_hour;
```

### 2. 刷新前端页面

刷新页面后，创建/编辑通道时会看到新增的速率控制配置项。

### 3. 配置通道

1. 打开通道管理页面
2. 点击"新建通道"或"编辑"现有通道
3. 找到"速率控制"部分
4. 开启速率控制开关
5. 设置各项限制值
6. 保存配置

### 4. 实现后端逻辑（可选）

如需实际生效，需要在后端实现速率限制逻辑。

## 总结

### ✅ 已完成

- [x] 数据库模型更新
- [x] 前端表单界面
- [x] 数据绑定
- [x] SQL 迁移脚本
- [x] 功能文档

### ⏳ 待完成

- [ ] 执行数据库迁移
- [ ] 后端速率限制实现
- [ ] Redis 集成
- [ ] 监控统计
- [ ] 测试验证

---

**功能时间**：2025-10-22  
**功能状态**：✅ 前端已完成，待数据库迁移和后端实现  
**下一步**：执行数据库迁移脚本
