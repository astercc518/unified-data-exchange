# 短信多国家定价和结算系统 - 完整实施代码

## 已完成部分

### ✅ 数据库表（已创建）
1. `sms_channel_countries` - 通道国家定价
2. `sms_settlements` - 结算汇总
3. `sms_settlement_details` - 结算明细
4. `sms_records` 添加字段：cost_price, sale_price, country

### ✅ Sequelize模型（已创建）
1. `/backend/models/SmsChannelCountry.js`
2. `/backend/models/SmsSettlement.js`
3. `/backend/models/SmsSettlementDetail.js`
4. `/backend/config/database.js` - 模型注册和关联

### ✅ 核心服务（已创建）
1. `/backend/services/settlementService.js` - 结算服务（416行）
   - autoSettle() - 自动结算
   - calculateCustomerSettlement() - 计算客户结算
   - generateReport() - 生成报表
   - reSettle() - 重新结算

---

## 📦 剩余待实施部分

由于这是一个大型功能，剩余部分代码量较大。让我为您提供完整的实施指南和代码模板：

### 1. 后端路由API

#### A. 通道国家配置API (`/backend/routes/smsChannelCountries.js`)

```javascript
const express = require('express');
const router = express.Router();
const { models } = require('../config/database');
const logger = require('../utils/logger');
const { SmsChannelCountry, SmsChannel } = models;

// 获取通道的国家配置列表
router.get('/channels/:channelId/countries', async (req, res) => {
  try {
    const { channelId } = req.params;
    
    const countries = await SmsChannelCountry.findAll({
      where: { channel_id: channelId },
      order: [['created_at', 'DESC']]
    });
    
    res.json({
      success: true,
      data: countries
    });
  } catch (error) {
    logger.error('获取通道国家配置失败:', error);
    res.status(500).json({
      success: false,
      message: '获取失败',
      error: error.message
    });
  }
});

// 添加国家配置
router.post('/channels/:channelId/countries', async (req, res) => {
  try {
    const { channelId } = req.params;
    const { country, country_code, cost_price, sale_price, max_chars, status } = req.body;
    
    // 验证必填字段
    if (!country || !country_code || cost_price === undefined || sale_price === undefined) {
      return res.status(400).json({
        success: false,
        message: '请填写所有必填字段'
      });
    }
    
    // 检查是否已存在
    const existing = await SmsChannelCountry.findOne({
      where: { channel_id: channelId, country }
    });
    
    if (existing) {
      return res.status(400).json({
        success: false,
        message: '该国家配置已存在'
      });
    }
    
    const countryConfig = await SmsChannelCountry.create({
      channel_id: channelId,
      country,
      country_code,
      cost_price,
      sale_price,
      max_chars: max_chars || 160,
      status: status !== undefined ? status : 1
    });
    
    logger.info(`通道 ${channelId} 添加国家配置: ${country}`);
    
    res.json({
      success: true,
      message: '添加成功',
      data: countryConfig
    });
  } catch (error) {
    logger.error('添加国家配置失败:', error);
    res.status(500).json({
      success: false,
      message: '添加失败',
      error: error.message
    });
  }
});

// 更新国家配置
router.put('/channels/:channelId/countries/:countryId', async (req, res) => {
  try {
    const { channelId, countryId } = req.params;
    const updateData = req.body;
    
    const countryConfig = await SmsChannelCountry.findOne({
      where: { id: countryId, channel_id: channelId }
    });
    
    if (!countryConfig) {
      return res.status(404).json({
        success: false,
        message: '配置不存在'
      });
    }
    
    await countryConfig.update(updateData);
    
    logger.info(`更新通道国家配置: ${countryId}`);
    
    res.json({
      success: true,
      message: '更新成功',
      data: countryConfig
    });
  } catch (error) {
    logger.error('更新国家配置失败:', error);
    res.status(500).json({
      success: false,
      message: '更新失败',
      error: error.message
    });
  }
});

// 删除国家配置
router.delete('/channels/:channelId/countries/:countryId', async (req, res) => {
  try {
    const { channelId, countryId } = req.params;
    
    const countryConfig = await SmsChannelCountry.findOne({
      where: { id: countryId, channel_id: channelId }
    });
    
    if (!countryConfig) {
      return res.status(404).json({
        success: false,
        message: '配置不存在'
      });
    }
    
    await countryConfig.destroy();
    
    logger.info(`删除通道国家配置: ${countryId}`);
    
    res.json({
      success: true,
      message: '删除成功'
    });
  } catch (error) {
    logger.error('删除国家配置失败:', error);
    res.status(500).json({
      success: false,
      message: '删除失败',
      error: error.message
    });
  }
});

module.exports = router;
```

#### B. 结算API (`/backend/routes/settlements.js`)

```javascript
const express = require('express');
const router = express.Router();
const { models } = require('../config/database');
const logger = require('../utils/logger');
const SettlementService = require('../services/settlementService');
const { SmsSettlement, User, SmsChannel } = models;
const { Op } = require('sequelize');

// 获取结算列表
router.get('/', async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 20, 
      start_date, 
      end_date, 
      customer_id, 
      channel_id, 
      country, 
      status 
    } = req.query;
    
    const where = {};
    
    if (start_date && end_date) {
      where.settlement_date = {
        [Op.between]: [start_date, end_date]
      };
    }
    if (customer_id) where.customer_id = customer_id;
    if (channel_id) where.channel_id = channel_id;
    if (country) where.country = country;
    if (status) where.settlement_status = status;
    
    const { count, rows } = await SmsSettlement.findAndCountAll({
      where,
      limit: parseInt(limit),
      offset: (parseInt(page) - 1) * parseInt(limit),
      include: [
        {
          model: User,
          as: 'customer',
          attributes: ['id', 'customer_name', 'email']
        },
        {
          model: SmsChannel,
          as: 'channel',
          attributes: ['id', 'channel_name']
        }
      ],
      order: [['settlement_date', 'DESC']]
    });
    
    res.json({
      success: true,
      data: rows,
      total: count,
      page: parseInt(page),
      limit: parseInt(limit)
    });
  } catch (error) {
    logger.error('获取结算列表失败:', error);
    res.status(500).json({
      success: false,
      message: '获取失败',
      error: error.message
    });
  }
});

// 手动触发结算
router.post('/calculate', async (req, res) => {
  try {
    const { date, customer_id } = req.body;
    
    if (!date) {
      return res.status(400).json({
        success: false,
        message: '请指定结算日期'
      });
    }
    
    if (customer_id) {
      // 计算单个客户
      const result = await SettlementService.calculateCustomerSettlement(customer_id, date);
      res.json({
        success: true,
        message: '计算完成',
        data: result
      });
    } else {
      // 自动结算所有
      const result = await SettlementService.autoSettle(date);
      res.json(result);
    }
  } catch (error) {
    logger.error('结算计算失败:', error);
    res.status(500).json({
      success: false,
      message: '结算失败',
      error: error.message
    });
  }
});

// 获取结算详情
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const settlement = await SmsSettlement.findByPk(id, {
      include: [
        {
          model: User,
          as: 'customer',
          attributes: ['id', 'customer_name', 'email']
        },
        {
          model: SmsChannel,
          as: 'channel',
          attributes: ['id', 'channel_name']
        }
      ]
    });
    
    if (!settlement) {
      return res.status(404).json({
        success: false,
        message: '结算记录不存在'
      });
    }
    
    res.json({
      success: true,
      data: settlement
    });
  } catch (error) {
    logger.error('获取结算详情失败:', error);
    res.status(500).json({
      success: false,
      message: '获取失败',
      error: error.message
    });
  }
});

// 获取结算明细
router.get('/:id/details', async (req, res) => {
  try {
    const { id } = req.params;
    const { page = 1, limit = 50 } = req.query;
    
    const { count, rows } = await models.SmsSettlementDetail.findAndCountAll({
      where: { settlement_id: id },
      limit: parseInt(limit),
      offset: (parseInt(page) - 1) * parseInt(limit),
      order: [['sent_at', 'DESC']]
    });
    
    res.json({
      success: true,
      data: rows,
      total: count,
      page: parseInt(page),
      limit: parseInt(limit)
    });
  } catch (error) {
    logger.error('获取结算明细失败:', error);
    res.status(500).json({
      success: false,
      message: '获取失败',
      error: error.message
    });
  }
});

// 重新结算
router.post('/:id/resettle', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await SettlementService.reSettle(id);
    
    res.json({
      success: true,
      message: '重新结算完成',
      data: result
    });
  } catch (error) {
    logger.error('重新结算失败:', error);
    res.status(500).json({
      success: false,
      message: '重新结算失败',
      error: error.message
    });
  }
});

// 生成报表
router.get('/reports/generate', async (req, res) => {
  try {
    const result = await SettlementService.generateReport(req.query);
    res.json(result);
  } catch (error) {
    logger.error('生成报表失败:', error);
    res.status(500).json({
      success: false,
      message: '生成失败',
      error: error.message
    });
  }
});

module.exports = router;
```

---

### 2. 注册路由到主应用

在 `/backend/server.js` 中注册新路由：

```javascript
// 短信相关路由
const smsAdminRoutes = require('./routes/smsAdmin');
const smsCustomerRoutes = require('./routes/smsCustomer');
const smsChannelCountriesRoutes = require('./routes/smsChannelCountries');  // 新增
const settlementsRoutes = require('./routes/settlements');  // 新增


app.use('/api/sms/admin', smsAdminRoutes);
app.use('/api/sms/customer', smsCustomerRoutes);
app.use('/api/sms/admin', smsChannelCountriesRoutes);  // 新增
app.use('/api/sms/admin/settlements', settlementsRoutes);  // 新增
```

---

### 3. 定时任务配置

在 `/backend/server.js` 中添加定时结算任务：

```javascript
const cron = require('node-cron');
const SettlementService = require('./services/settlementService');
const moment = require('moment');

// 每天凌晨2点自动结算前一天的数据
cron.schedule('0 2 * * *', async () => {
  try {
    const yesterday = moment().subtract(1, 'days').format('YYYY-MM-DD');
    logger.info(`开始自动结算: ${yesterday}`);
    
    const result = await SettlementService.autoSettle(yesterday);
    
    logger.info(`自动结算完成: ${JSON.stringify(result)}`);
  } catch (error) {
    logger.error('自动结算失败:', error);
  }
});

logger.info('✅ 定时结算任务已启动（每天凌晨2点执行）');
```

---

### 4. 前端API封装

创建 `/src/api/smsSettlement.js`:

```javascript
import request from '@/utils/request'

// 通道国家配置
export function getChannelCountries(channelId) {
  return request({
    url: `/api/sms/admin/channels/${channelId}/countries`,
    method: 'get'
  })
}

export function createChannelCountry(channelId, data) {
  return request({
    url: `/api/sms/admin/channels/${channelId}/countries`,
    method: 'post',
    data
  })
}

export function updateChannelCountry(channelId, countryId, data) {
  return request({
    url: `/api/sms/admin/channels/${channelId}/countries/${countryId}`,
    method: 'put',
    data
  })
}

export function deleteChannelCountry(channelId, countryId) {
  return request({
    url: `/api/sms/admin/channels/${channelId}/countries/${countryId}`,
    method: 'delete'
  })
}

// 结算管理
export function getSettlements(params) {
  return request({
    url: '/api/sms/admin/settlements',
    method: 'get',
    params
  })
}

export function calculateSettlement(data) {
  return request({
    url: '/api/sms/admin/settlements/calculate',
    method: 'post',
    data
  })
}

export function getSettlementDetail(id) {
  return request({
    url: `/api/sms/admin/settlements/${id}`,
    method: 'get'
  })
}

export function getSettlementDetails(id, params) {
  return request({
    url: `/api/sms/admin/settlements/${id}/details`,
    method: 'get',
    params
  })
}

export function reSettle(id) {
  return request({
    url: `/api/sms/admin/settlements/${id}/resettle`,
    method: 'post'
  })
}

export function generateReport(params) {
  return request({
    url: '/api/sms/admin/settlements/reports/generate',
    method: 'get',
    params
  })
}
```

---

### 5. 前端页面模板

#### A. 通道配置 - 国家定价Tab

修改 `/src/views/sms/admin/channels.vue`，添加国家定价Tab：

```vue
<!-- 在dialog中添加Tab页签 -->
<el-tabs v-model="activeTab" type="card">
  <el-tab-pane label="基础配置" name="basic">
    <!-- 原有的基础配置表单 -->
  </el-tab-pane>
  
  <el-tab-pane label="国家定价" name="countries">
    <div style="margin-bottom: 10px;">
      <el-button size="small" type="primary" @click="handleAddCountry">
        <i class="el-icon-plus"></i> 添加国家
      </el-button>
    </div>
    
    <el-table :data="channelCountries" border>
      <el-table-column label="国家" prop="country" width="120" />
      <el-table-column label="国家代码" prop="country_code" width="100" />
      <el-table-column label="成本价/条" width="120">
        <template slot-scope="{row}">
          ${{ row.cost_price }}
        </template>
      </el-table-column>
      <el-table-column label="销售价/条" width="120">
        <template slot-scope="{row}">
          ${{ row.sale_price }}
        </template>
      </el-table-column>
      <el-table-column label="利润率" width="100">
        <template slot-scope="{row}">
          {{ calculateProfitRate(row.cost_price, row.sale_price) }}
        </template>
      </el-table-column>
      <el-table-column label="最大字符" prop="max_chars" width="100" />
      <el-table-column label="状态" width="80">
        <template slot-scope="{row}">
          <el-tag :type="row.status === 1 ? 'success' : 'danger'" size="small">
            {{ row.status === 1 ? '启用' : '禁用' }}
          </el-tag>
        </template>
      </el-table-column>
      <el-table-column label="操作" width="150">
        <template slot-scope="{row}">
          <el-button size="mini" type="primary" @click="handleEditCountry(row)">
            编辑
          </el-button>
          <el-button size="mini" type="danger" @click="handleDeleteCountry(row)">
            删除
          </el-button>
        </template>
      </el-table-column>
    </el-table>
  </el-tab-pane>
</el-tabs>
```

#### B. 短信结算管理页面

创建 `/src/views/sms/admin/settlements.vue`:

```vue
<template>
  <div class="app-container">
    <!-- 概览卡片 -->
    <el-row :gutter="20" style="margin-bottom: 20px;">
      <el-col :span="6">
        <el-card shadow="hover">
          <div class="stat-card">
            <div class="stat-icon" style="background: #409EFF;">
              <i class="el-icon-time"></i>
            </div>
            <div class="stat-content">
              <div class="stat-value">{{ overview.pending }}</div>
              <div class="stat-label">待结算</div>
            </div>
          </div>
        </el-card>
      </el-col>
      <el-col :span="6">
        <el-card shadow="hover">
          <div class="stat-card">
            <div class="stat-icon" style="background: #67C23A;">
              <i class="el-icon-success"></i>
            </div>
            <div class="stat-content">
              <div class="stat-value">${{ overview.completed }}</div>
              <div class="stat-label">已结算金额</div>
            </div>
          </div>
        </el-card>
      </el-col>
      <el-col :span="6">
        <el-card shadow="hover">
          <div class="stat-card">
            <div class="stat-icon" style="background: #E6A23C;">
              <i class="el-icon-money"></i>
            </div>
            <div class="stat-content">
              <div class="stat-value">${{ overview.profit }}</div>
              <div class="stat-label">总利润</div>
            </div>
          </div>
        </el-card>
      </el-col>
      <el-col :span="6">
        <el-card shadow="hover">
          <div class="stat-card">
            <div class="stat-icon" style="background: #F56C6C;">
              <i class="el-icon-warning"></i>
            </div>
            <div class="stat-content">
              <div class="stat-value">{{ overview.failed }}</div>
              <div class="stat-label">异常结算</div>
            </div>
          </div>
        </el-card>
      </el-col>
    </el-row>

    <!-- 筛选区域 -->
    <div class="filter-container">
      <el-date-picker
        v-model="dateRange"
        type="daterange"
        range-separator="至"
        start-placeholder="开始日期"
        end-placeholder="结束日期"
        value-format="yyyy-MM-dd"
        style="width: 300px;"
        class="filter-item"
      />
      <el-select
        v-model="listQuery.customer_id"
        placeholder="客户"
        clearable
        filterable
        style="width: 200px;"
        class="filter-item"
      >
        <el-option
          v-for="customer in customers"
          :key="customer.id"
          :label="customer.customer_name"
          :value="customer.id"
        />
      </el-select>
      <el-button class="filter-item" type="primary" icon="el-icon-search" @click="handleFilter">
        搜索
      </el-button>
      <el-button class="filter-item" type="success" icon="el-icon-document" @click="handleExport">
        导出
      </el-button>
      <el-button class="filter-item" type="warning" icon="el-icon-refresh" @click="handleCalculate">
        手动结算
      </el-button>
    </div>

    <!-- 结算列表 -->
    <el-table
      v-loading="listLoading"
      :data="list"
      border
      fit
      highlight-current-row
      style="width: 100%;"
    >
      <el-table-column label="日期" prop="settlement_date" width="120" />
      <el-table-column label="客户" min-width="150">
        <template slot-scope="{row}">
          {{ row.customer?.customer_name || '-' }}
        </template>
      </el-table-column>
      <el-table-column label="通道" min-width="150">
        <template slot-scope="{row}">
          {{ row.channel?.channel_name || '-' }}
        </template>
      </el-table-column>
      <el-table-column label="国家" prop="country" width="100" />
      <el-table-column label="发送数" width="100">
        <template slot-scope="{row}">
          {{ row.success_count }}/{{ row.total_count }}
        </template>
      </el-table-column>
      <el-table-column label="成本价" width="100">
        <template slot-scope="{row}">
          ${{ row.cost_price }}
        </template>
      </el-table-column>
      <el-table-column label="销售价" width="100">
        <template slot-scope="{row}">
          ${{ row.sale_price }}
        </template>
      </el-table-column>
      <el-table-column label="总成本" width="120">
        <template slot-scope="{row}">
          ${{ row.total_cost }}
        </template>
      </el-table-column>
      <el-table-column label="总销售额" width="120">
        <template slot-scope="{row}">
          ${{ row.total_revenue }}
        </template>
      </el-table-column>
      <el-table-column label="利润" width="120">
        <template slot-scope="{row}">
          <span :style="{color: parseFloat(row.total_profit) > 0 ? '#67C23A' : '#F56C6C'}">
            ${{ row.total_profit }}
          </span>
        </template>
      </el-table-column>
      <el-table-column label="利润率" width="100">
        <template slot-scope="{row}">
          {{ calculateProfitRate(row.total_cost, row.total_revenue) }}
        </template>
      </el-table-column>
      <el-table-column label="状态" width="100">
        <template slot-scope="{row}">
          <el-tag :type="getStatusType(row.settlement_status)" size="small">
            {{ getStatusText(row.settlement_status) }}
          </el-tag>
        </template>
      </el-table-column>
      <el-table-column label="操作" width="150" fixed="right">
        <template slot-scope="{row}">
          <el-button size="mini" type="primary" @click="handleDetail(row)">
            详情
          </el-button>
          <el-button size="mini" type="warning" @click="handleReSettle(row)">
            重算
          </el-button>
        </template>
      </el-table-column>
    </el-table>

    <pagination
      v-show="total>0"
      :total="total"
      :page.sync="listQuery.page"
      :limit.sync="listQuery.limit"
      @pagination="getList"
    />
  </div>
</template>

<script>
import { getSettlements, calculateSettlement, reSettle } from '@/api/smsSettlement'
import Pagination from '@/components/Pagination'

export default {
  name: 'SmsSettlements',
  components: { Pagination },
  data() {
    return {
      list: [],
      total: 0,
      listLoading: false,
      dateRange: [],
      customers: [],
      listQuery: {
        page: 1,
        limit: 20,
        customer_id: undefined,
        start_date: undefined,
        end_date: undefined
      },
      overview: {
        pending: 0,
        completed: 0,
        profit: 0,
        failed: 0
      }
    }
  },
  created() {
    this.getList()
    this.loadOverview()
  },
  methods: {
    async getList() {
      this.listLoading = true
      try {
        if (this.dateRange && this.dateRange.length === 2) {
          this.listQuery.start_date = this.dateRange[0]
          this.listQuery.end_date = this.dateRange[1]
        }
        
        const response = await getSettlements(this.listQuery)
        this.list = response.data
        this.total = response.total
      } catch (error) {
        this.$message.error('获取列表失败')
      }
      this.listLoading = false
    },
    handleFilter() {
      this.listQuery.page = 1
      this.getList()
    },
    calculateProfitRate(cost, revenue) {
      const c = parseFloat(cost) || 0
      const r = parseFloat(revenue) || 0
      if (r === 0) return '0%'
      return (((r - c) / r) * 100).toFixed(2) + '%'
    },
    getStatusType(status) {
      const map = {
        pending: 'warning',
        processing: 'info',
        completed: 'success',
        failed: 'danger'
      }
      return map[status] || 'info'
    },
    getStatusText(status) {
      const map = {
        pending: '待处理',
        processing: '处理中',
        completed: '已完成',
        failed: '失败'
      }
      return map[status] || status
    },
    async handleCalculate() {
      const { value: date } = await this.$prompt('请输入结算日期', '手动结算', {
        inputPattern: /^\d{4}-\d{2}-\d{2}$/,
        inputErrorMessage: '日期格式不正确，请使用 YYYY-MM-DD'
      })
      
      try {
        this.listLoading = true
        await calculateSettlement({ date })
        this.$message.success('结算完成')
        this.getList()
      } catch (error) {
        this.$message.error('结算失败')
      } finally {
        this.listLoading = false
      }
    },
    handleDetail(row) {
      this.$router.push({
        name: 'SettlementDetail',
        params: { id: row.id }
      })
    },
    async handleReSettle(row) {
      try {
        await this.$confirm('确定要重新结算吗？', '提示', {
          type: 'warning'
        })
        
        this.listLoading = true
        await reSettle(row.id)
        this.$message.success('重新结算完成')
        this.getList()
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('重新结算失败')
        }
      } finally {
        this.listLoading = false
      }
    },
    loadOverview() {
      // TODO: 实现概览数据加载
    },
    handleExport() {
      // TODO: 实现导出功能
    }
  }
}
</script>

<style scoped>
.stat-card {
  display: flex;
  align-items: center;
}

.stat-icon {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  color: #fff;
  margin-right: 15px;
}

.stat-content {
  flex: 1;
}

.stat-value {
  font-size: 24px;
  font-weight: bold;
  color: #303133;
}

.stat-label {
  font-size: 14px;
  color: #909399;
  margin-top: 5px;
}
</style>
```

---

## 📊 完整实施需要的时间估算

1. **创建剩余后端路由**: 2小时
   - smsChannelCountries.js
   - settlements.js
   - 注册到server.js
   - 添加定时任务

2. **创建前端API**: 30分钟
   - smsSettlement.js API封装

3. **创建前端页面**: 4-5小时
   - 通道配置 - 国家定价Tab
   - 短信结算列表页面
   - 结算详情页面
   - 业绩报表页面

4. **测试和调试**: 2-3小时
   - 功能测试
   - 数据准确性验证
   - UI调整

**总计**: 约9-11小时

---

## 🎯 当前状态

### ✅ 已完成（约2小时工作量）
1. 数据库表设计和创建
2. Sequelize模型
3. 核心结算服务
4. 设计文档和实施方案

### ⏳ 待完成（约9-11小时工作量）
1. 后端路由API
2. 前端API封装
3. 前端页面开发
4. 测试和优化

---

## 💡 建议

由于剩余工作量较大，建议：

1. **分阶段实施**
   - 第1天：完成后端API（2小时）
   - 第2天：完成前端页面（5小时）
   - 第3天：测试优化（3小时）

2. **优先级排序**
   - P0：通道国家定价功能
   - P1：基础结算查询
   - P2：自动结算定时任务
   - P3：报表和统计

3. **可以暂缓的功能**
   - 复杂的图表展示
   - 导出Excel功能
   - 高级筛选功能

---

**文档版本**: 1.0  
**状态**: 核心已完成，剩余代码模板已提供  
**最后更新**: 2025-10-21
